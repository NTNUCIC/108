<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>PL</title>

		<link rel="icon" type="image/x-icon" href="../../images/favicon.ico">
		<link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.ico">

		<meta name="og:title" content="PL">
		<meta name="og:url" content="http://ntnucic.github.io/104/slides/20151022-PL/index.html">
		<meta name="og:description" content="國立臺灣師範大學資訊研究社程式語言課程投影片">
		<meta name="og:image" content="../../images/cic.jpg">
		<meta name="og:site_name" content="NTNUCIC">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/black.css" id="theme">

		<link rel="stylesheet" href="../lib/css/zenburn.css">

		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );

		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<div class="slides">

			<section>
				<h1 style="margin-top:100px">程式語言</h1>
					<h4>林品儒</h4>
					<h4>2015/10/22</h4>
			</section>
			
			<section>
				<h2>程式語言</h2>
				<p class="fragment">利用標準化的指令定義電腦的行動</p>
				<p class="fragment">但是比電腦更早被發明出來</p>
				<p class="fragment">自動織布機、自動演奏鋼琴</p>
			</section>
			
			<section>
				<h2>程式語言的歷史</h2>
				<p class="fragment">&lt;1940：打孔機</p>
				<p class="fragment">194X：組合語言</p>
				<p class="fragment">195X-196X：高階語言發明</p>
				<p class="fragment">197X：基礎範式確立</p>
				<p class="fragment">198X：功能強化</p>
				<p class="fragment">&gt;1990：百家爭鳴</p>
			</section>
			
			<section>
				<section>
					<h1>1940年代前</h1>
				</section>
			
				<section>
					<h2>電腦發明之前</h2>
					<img class="fragment" src="./360px-Analytical_Engine_(2290032530).jpg">
					<p class="fragment" style="font-size: 12px" >
					<a href="https://commons.wikimedia.org/wiki/File:Analytical_Engine_(2290032530).jpg#/media/File:Analytical_Engine_(2290032530).jpg">Analytical Engine (2290032530)</a>" 由 <a rel="nofollow" class="external text" href="http://www.flickr.com/people/8399025@N07">Marcin Wichary</a> from San Francisco, U.S.A. - <a rel="nofollow" class="external text" href="http://www.flickr.com/photos/8399025@N07/2290032530/">Analytical Engine Mill</a>。 使用來自 <a href="https://commons.wikimedia.org/wiki/">維基共享資源</a> 的 <a title="Creative Commons Attribution 2.0" href="http://creativecommons.org/licenses/by/2.0">知識共享 署名 2.0</a> 條款授權。
					</p>
				</section>
				
				<section>
					<h2>分析機</h2>
					<p class="fragment">蒸氣驅動，打孔紙帶輸入</p>
					<p class="fragment">四則運算、比較、求平方根</p>
					<p class="fragment">1871年被發明</p>
					<p class="fragment">使用的語言類似於今天的程式語言</p>
				</section>
			</section>
			
			<section>
				<section>
					<h1>1940年代</h1>
				</section>
			
				<section>
					<h2>組合語言</h2>
					<p class="fragment">當時只是數字的填空遊戲</p>
					<img class="fragment" src="./EONGx.png">
					<p class="fragment">這張圖是MIPS的格式(雖然是1981才發明)</p>
					<p class="fragment" style="font-size: 12px">http://stackoverflow.com/questions/23123106/mips-i-instruction-immediate-field</p>
				</section>
				
				<section>
					<h2>馮紐曼的八卦</h2>
					<p class="fragment">沒錯就是那個天才</p>
					<p class="fragment">他的學生花時間弄組譯器(assembler)被他發現</p>
					<p class="fragment" style="color:red"><strong>It is a waste of a valuable scientific computing instrument to use it to do clerical work</strong></p>
					<p class="fragment"><del>拿珍貴的計算工具做文書工作真是暴殄天物</del></p>
				</section>
				
				<section>
					<h2>組合語言vs機械語言</h2>
					<p class="fragment">底下是x86格式的機械語言和組合語言</p>
					<pre class="fragment" style="left:auto;right:auto;width:600px;"><code class="x86asm" style="font-family: 'consolas','Ubuntu Mono'">
8d 74 26 00          lea    0x0(%esi,%eiz,1),%esi
8b 54 24 28          mov    0x28(%esp),%edx
89 44 24 04          mov    %eax,0x4(%esp)
8b 44 24 20          mov    0x20(%esp),%eax
89 54 24 08          mov    %edx,0x8(%esp)
89 04 24             mov    %eax,(%esp)
e8 38 06 00 00       call   6b902250 &lt;___mingw_TLScallback&gt;
b8 01 00 00 00       mov    $0x1,%eax
83 c4 1c             add    $0x1c,%esp
c2 0c 00             ret    $0xc
					</code></pre>
					<p class="fragment"><del>假如機械語言友善方便誰還要當丐幫</del></p>
				</section>
				
				<section>
					<h2>接下來</h2>
					<p class="fragment">全部都是數字太恐怖了!!</p>
					<p class="fragment">不能逃不能逃</p>
					<p class="fragment">於是高階語言就出來拯救世界</p>
				</section>
			</section>
			
			<section>
				<section>
					<h1>1950~1960年代</h1>
				</section>
				
				<section>
					<h2>高階語言發明</h2>
					<p class="fragment">1957-Fortran(<strong>FOR</strong>mula <strong>TRAN</strong>slator)</p>
					<p class="fragment">1958-LISP(<strong>LIS</strong>t <strong>P</strong>rocessor)</p>
					<p class="fragment">1960-COBOL(<strong>CO</strong>mmon <strong>B</strong>usiness <strong>O</strong>riented <strong>L</strong>anguage)</p>
					<p class="fragment">到現在還是很有用處</p>
				</section>
				
				<section>
					<h2>Fortran</h2>
					<p class="fragment">第一個正式採用且現在還活著的高階語言</p>
					<p class="fragment">用在數學及科學的計算</p>
					<p class="fragment">計算矩陣和複數很方便</p>
					<p class="fragment">整合在GCC中</p>
				</section>
				
				<section>
					<h2>LISP</h2>
					<p class="fragment">第二個被發明的高階語言</p>
					<p class="fragment">函數性程式語言</p>
					<p class="fragment">其帶來的概念被其他語言所吸收</p>
				</section>
				
				<section>
					<h2>LISP</h2>
					<p class="fragment">以下為比較是否同號的程式碼</p>
					<pre class="fragment" style="left:auto;right:auto;width:600px;"><code class="lisp" style="font-size:28px;font-family: 'consolas','Ubuntu Mono'">
(defun same-sign (x y)
	(or (and (zerop x) (zerop y))
		(and (&lt; x 0) (&lt; y 0))
		(and (&gt; x 0) (&gt; y 0))))
					</code></pre>
				</section>
					
				<section>
					<h2>函數性語言設計</h2>
					<p class="fragment">將電腦運算視為數學上的函式計算</p>
					<p class="fragment">避免程式的內部狀態</p>
					<p class="fragment">避免可以被改變的物件</p>
					<p class="fragment">可以將函式當引數傳入</p>
				</section>
				
				<section>
					<h2>避免副作用</h2>
					<p class="fragment">唉呦~副作用有很嚴重嗎?</p>
					<pre class="fragment" style="left:auto;right:auto;width:600px;"><code class="c++" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
#include &lt;stdio.h&gt;
int main(){
	int num = 100;
	int *p[3] = { &amp;num, &amp;num, &amp;num };
	*p[0] = 200;
	printf( "%d %d %d", *p[0], *p[1], *p[2]);
}
					</code></pre>
					<p class="fragment" style="color:red">恭喜你得到3個200!!</p>
				</section>
				
				<section>
					<h2>函式當引數傳入</h2>
					<p class="fragment">這個等等會再講到</p>
					<pre class="fragment" style="left:auto;right:auto;width:600px;"><code class="c++" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
#include&lt;stdio.h&gt;
int add(int a,int b){ return a+b; }
int call(int a, int b, int (*func)(int a,int b)){
    return (*func)(a,b);
}
int main(){
    printf("%d",call(100,200,add));
}
					</code></pre>
					<p class="fragment">當然有其他更強大的功能</p>
				</section>
				
				<section>
					<h2>接下來</h2>
					<p class="fragment">程式語言慢慢發展出了更多概念</p>
				</section>
			</section>
			
			<section>
				<section>
					<h1>1970年代</h1>
				</section>
				
				<section>
					<h2>基礎範式確立</h2>
					<p class="fragment">C</p>
					<p class="fragment">Pascal</p>
					<p class="fragment">Prolog</p>
					<p class="fragment">Smalltalk</p>
				</section>
				
				<section>
					<h2>C語言演進歷史</h2>
					<p class="fragment">CPL</p>
					<p class="fragment">BCPL</p>
					<p class="fragment">B</p>
					<p class="fragment">C</p>
				</section>
				
				<section>
					<h2>BCPL</h2>
					<pre style="left:auto;right:auto;width:600px;"><code style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
GET "LIBHDR"

LET START() = VALOF $(
	FOR I = 1 TO 5 DO
		WRITEF("%N! = %I4*N", I, FACT(I))
	RESULTIS 0
$)

AND FACT(N) = N = 0 -> 1, N * FACT(N - 1)
					</code></pre>
				</section>
				
				<section>
					<h2>B語言</h2>
					<pre style="left:auto;right:auto;width:800px;"><code class="c" style="font-size:22px;font-family: 'consolas','Ubuntu Mono'">
/* The following function will print a non-negative number, n, to
	 the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that
	 in the ASCII character set, the digits 0 to 9 have sequential
	 code values.  */

printn(n, b) {
	extrn putchar;
	auto a;

	if (a = n / b)        /* assignment, not test for equality */
		printn(a, b); /* recursive */
	putchar(n % b + '0');
}
					</code></pre>
				</section>
				
				<section>
					<h2>C語言</h2>
					<p class="fragment">由B語言改進而來</p>
					<p class="fragment">廣泛使用在與硬體相關的環境下</p>
					<p class="fragment">結構化程式設計</p>
				</section>
				
				<section>
					<h2>結構化程式設計</h2>
					<p class="fragment">循序結構-直直跑下去</p>
					<p class="fragment">選擇結構-if,switch</p>
					<p class="fragment">重複結構-for,while</p>
					<p class="fragment">程式可以以流程圖表示</p>
				</section>
				
				<section>
					<h2>非結構化程式設計</h2>
					<pre class="fragment" style="left:auto;right:auto;width:700px;"><code class="c" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
#include&lt;stdio.h&gt;
int main(){
	int i=0;
outer:
	int j=0;
inner:
	printf("*");
	j++;
	if(j&lt;5){goto inner;}
	printf("\n");
	i++;
	if(i&lt;5){goto outer;}
}
					</code></pre>
					<p class="fragment">其實只是印5*5的星星</p>
				</section>
				
				<section>
					<h2>結構化程式設計</h2>
					<pre class="fragment" style="left:auto;right:auto;width:700px;"><code class="c" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
#include&lt;stdio.h&gt;
int main(){
	for(int i=0;i&lt;5;i++){
		for(int j=0;j&lt;5;j++){
			printf("*");
		}
		printf("\n");
	}
}
					</code></pre>
				</section>
				
				<section>
					<h2>Pascal</h2>
					<p class="fragment">因為有指標以前用來上資料結構</p>
					<p class="fragment">linss："C難看死了，Pascal多優美啊"</p>
					<p class="fragment">時代的眼淚</p>
				</section>
				
				<section>
					<h2>Prolog</h2>
					<p class="fragment">運用在自然語言與人工智慧</p>
					<p class="fragment">邏輯程式設計</p>
					<p class="fragment">定義答案所需要的規則由電腦執行之</p>
					<pre class="fragment" style="left:auto;right:auto;width:800px;"><code class="prolog" style="font-size:30px;font-family: 'consolas','Ubuntu Mono'">
power(N,0,1):- !.
power(N,K,R):- K1 is K-1,power(N,K1,R1),R is R1*N.
					</code></pre>
				</section>
				
				<section>
					<h2>Smalltalk</h2>
					<p class="fragment">所有的東西都是物件(連條件和重複語句也是)</p>
					<p class="fragment">物件導向程式設計</p>
					<pre class="fragment" style="left:auto;right:auto;width:800px;"><code class="st" style="font-size:22px;font-family: 'consolas','Ubuntu Mono'">
| rectangles aPoint collisions |
rectangles := OrderedCollection 
  with: (Rectangle left: 0 right: 10 top: 100 bottom: 200)
  with: (Rectangle left: 10 right: 10 top: 110 bottom: 210).
aPoint := Point x: 20 y: 20.
collisions := rectangles select: [:aRect | aRect containsPoint: aPoint].
					</code></pre>
				</section>
				
				<section>
					<h2>物件導向程式設計</h2>
					<p class="fragment">將程式和資料封裝在類別的實體中</p>
					<p class="fragment">繼承</p>
					<p class="fragment">封裝</p>
					<p class="fragment">多型</p>
				</section>
				
				<section>
					<h2>繼承</h2>
					<p class="fragment">獲得原先的屬性和行為</p>
					<pre class="fragment" style="left:auto;right:auto;width:700px;"><code class="rb" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
class Bomb
	def explode
		print "你已經死了"
	end
end
class MadeInChina &lt; Bomb;end
MadeInChina.new.explode #=> 你已經死了
					</code></pre>
				</section>
				
				<section>
					<h2>封裝</h2>
					<p class="fragment">隱藏程式內部的具體執行步驟</p>
					<pre class="fragment" style="left:auto;right:auto;width:700px;"><code class="rb" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
class Killer
private
	def drink_coffee;end
	def read_news_paper;end
	def time_to_die
		print "你已經死了"
	end
public
	def assassinate
		drink_coffee
		read_news_paper
		time_to_die
	end
end
					</code></pre>
				</section>
				
				<section>
					<h2>多型</h2>
					<p class="fragment">不同類別對於同樣呼叫有不同的行為</p>
					<pre class="fragment" style="left:auto;right:auto;width:700px;"><code class="rb" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
class Wine
	def drunk
		print "讚啦~~"
	end
end
class FakeWine
	def drunk
		print "你已經死了"
	end
end
					</code></pre>
				</section>
				
				<section>
					<h2>接下來</h2>
					<p class="fragment">接下來的時代是上個時代的持續成長</p>
					<p class="fragment">將之前的構想發揚光大</p>
				</section>
			</section>
			
			<section>
				<section>
					<h1>1980年代</h1>
				</section>
				
				<section>
					<h2>功能強化</h2>
					<p class="fragment">Ada</p>
					<p class="fragment">C++</p>
					<p class="fragment">Perl</p>
				</section>
				
				<section>
					<h2>Ada</h2>
					<p class="fragment">統合美軍系統的語言之用</p>
					<p class="fragment">命名由來為愛達·勒芙蕾絲，她是第一位電腦程式設計師</p>
					<p class="fragment">雖然很嚴謹但是還是有火箭炸了...</p>
					<p class="fragment">整合在GCC中</p>
				</section>
				
				<section>
					<h2>C++</h2>
					<p class="fragment">本來稱為C&nbsp;with&nbsp;classes</p>
					<p class="fragment">除了物件導向還有模版系統</p>
					<p class="fragment">現在連lambda特性都加入了</p>
					<p class="fragment">C++11,C++14...</p>
				</section>
				
				<section>
					<h2>C++模版</h2>
					<pre class="fragment" style="left:auto;right:auto;width:600px;"><code class="c++" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
template &lt;int N&gt;
struct Factorial {
    enum { value = N * Factorial&lt;N - 1&gt;::value };
};
template &lt;&gt;
struct Factorial&lt;0&gt; {
    enum { value = 1 };
};
void foo()
{
    int x = Factorial&lt;4&gt;::value; // == 24
    int y = Factorial&lt;0&gt;::value; // == 1
}
</code></pre>
				</section>
				
				<section>
					<h2>C++11的lambda</h2>
					<p class="fragment">長得很像之前的功能齁</p>
					<pre class="fragment" style="left:auto;right:auto;width:650px;"><code class="c++" style="font-size:24px;font-family: 'consolas','Ubuntu Mono'">
#include&lt;stdio.h&gt;
int call(int a,int b,int (*func)(int,int)){
    return func(a,b);
}
int main(){
    auto add = [](int a, int b) { return a + b; };
    printf("%d",call(100,200,add));
}
					</code></pre>
					<p class="fragment">反正看不太懂就是了</p>
				</section>
				
				<section>
					<h2>Perl</h2>
					<p class="fragment">多用途的直譯式語言</p>
					<p class="fragment">"不只一種方法來做一件事"</p>
					<p class="fragment">因為自由度太高所以可讀性差...</p>
				</section>
				
				<section>
					<h2>Perl的神code</h2>
					<p class="fragment">說可讀性差?哪有可能啊</p>
					<pre class="fragment" style="left:auto;right:auto;width:1000px;"><code class="perl" style="font-size:20px;font-family: 'consolas','Ubuntu Mono'">
$_='while(read+STDIN,$_,2048){$a=29;$b=73;$c=142;$t=255;
@t=map{$_%16or$t^=$c^=( $m=(11,10,116,100,11,122,20,100)[$_/16%8])&amp;110;
$t^=(72,@z=(64,72,$a^=12*($_%16 -2?0:$m&amp;17)),$b^=$_%64?12:0,@z)[$_%8]}(16..271);
if((@a=unx"C*",$_)[20]&amp;48){$h =5;$_=unxb24,join"",@b=map{xB8,unxb8,chr($_^$a[--$h+84])}@ARGV;s/…$/1$&amp;/;
$d=unxV,xb25,$_;$e=256|(ord$b[4])&lt;&lt;9|ord$b[3];
$d=$d8^($f=$t&amp;($d12^$d4^ $d^$d/8))&lt;&lt;17,$e=$e8^($t&amp;($g=($q=$e14&amp;7^$e)^$q*8^$q&lt;&lt;6))&lt;&lt;9,$_=$t[$_]^ (($h=8)+=$f+(~$g&amp;$t))for@a [128..$#a]}print+x"C*",@a}';
s/x/pack+/g;eval
					</code></pre>
					<p class="fragment"><del>請吃雞排的時候到了</del></p>
				</section>
				
				<section>
					<h2>接下來</h2>
					<p class="fragment">生產力也被視為語言的重要指標</p>
					<p class="fragment">網際網路時代來啦~~</p>
				</section>
			</section>
			
			<!--
			程式語言的歷史
			ASM
			
			C/C++/Java
			
			LISP
			Prolog
			
			Ruby
			Python
			Perl
			-->
			</div>
		</div>
		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>

		<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
				{ src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: '../plugin/zoom-js/zoom.js', async: true },
				{ src: '../plugin/notes/notes.js', async: true }
			]
		});
		</script>
	</body>
</html>